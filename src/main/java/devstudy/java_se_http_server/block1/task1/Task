<h4><strong>Основное домашнее задание</strong></h4>
<ol><li><p>Добавить метод <strong>int remove(int index) </strong>в класс <strong>DynaArray</strong>, который  удалит элемент из динамического массива по индексу и вернет удаленный  элемент;</p></li><li><p>Реализовать класс <strong>LinkedList </strong>(класс реализации двусвязного списка) (+<strong>LinkedListTest</strong>);<br> <em>Описание структуры данных двусвязный список на примере стандартного Java класса доступно по ссылке </em><a href="https://habrahabr.ru/post/127864/" rel="noopener noreferrer" target="_blank"><em>LinkedList</em></a><em>  (Ваша задача написать упрощенный аналог стандартного класса, чтобы разобраться как он работает) </em> </p></li><li><p>Реализовать класс очереди <strong>Queue</strong>;</p></li><li><p>Реализовать класс стека <strong>Stack</strong>;</p></li></ol><p><strong>Решение данного задание описывается в следующей лекции</strong></p><p><br></p><p><br></p><h4><strong>Дополнительное домашнее задание</strong></h4><p><em>(Данные задания необходимо выполнить после основного домашнего задания для закрепления пройденного материала)</em></p><ol><li><p><strong>Задание:</strong> Создать класс комплексных чисел Complex (<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE" rel="noopener noreferrer" target="_blank">Википедия</a>) и реализовать в классе методы:  </p><ul><li><p>конструктор Complex(double x, double y) для создания комплексного числа с x-вещественной частью, y-мнимой частью;</p></li><li><p>метод String getValue() - данный метод возвращает строковое представление комплексного числа (т.е. такое: x+iy);</p></li><li><p>getters и setters для вещественной и мнимой части комплексного числа;</p></li><li><p>метод Complex add(Complex secondArgument) - возвращает новый объект  комплексного числа, которое равно сумме текущего числа и secondArgument  (см. в Википедии о правилах сложения комплексных чисел);</p></li><li><p>метод Complex sub(Complex secondArgument) - возвращает новый объект  комплексного числа, которое равно разности текущего числа и  secondArgument (см. в Википедии о правилах вычитания комплексных чисел);</p></li><li><p>метод Complex mul(Complex secondArgument) - возвращает новый объект  комплексного числа, которое равно произведению текущего числа и  secondArgument (см. в Википедии о правилах произведения комплексных  чисел);</p></li><li><p>метод Complex div(Complex secondArgument) - возвращает новый объект  комплексного числа, которое равно частному от деления текущего числа на  secondArgument (см. в Википедии о правилах деления комплексных чисел);</p></li></ul><p> Добавить в классе Complex метод main, в котором протестировать все методы.  <br><strong>Решение: </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/Complex.java" rel="noopener noreferrer" target="_blank"><strong>Complex.java</strong></a><strong> </strong></p><p><br></p></li><li><p><strong>Задание:</strong> Создать класс матрицы (Matrix) double чисел размерностью rows и cols и реализовать в классе методы: </p><ul><li><p>конструктор матрицы public Matrix(int rows, int cols), где rows - количество строк, cols - количество столбцов матрицы;</p></li><li><p>метод void fill(double value) - данный метод заполнит матрицу значением value;</p></li><li><p>методы getRows(), getCols();</p></li><li><p>метод void print() - метод, который печатает матрицу в стандартный  поток вывода System.out. Матрица должна быть напечатана в виде таблицы:  сначала первая строка, затем вторая и т.д;</p></li><li><p>метод Matrix transpose() - данный метод возвращает новую матрицу,  которая является транспонированной версией текущей матрицы.  (Транспонирование означает переворачивание матрицы: у исходной матрицы  есть строки и столбцы, у транспонированной матрицы строки становятся  столбцами, а столбцы строками).</p></li></ul><p> Добавить в классе Matrix метод main, в котором протестировать все методы. <br><strong>Решение: </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/Matrix.java" rel="noopener noreferrer" target="_blank"><strong>Matrix.java</strong></a><strong> </strong></p><p><br></p></li><li><p><strong>Задание:</strong> Создать класс односвязного списка LinkedList c  методами add, get, remove, size, clear, toArray. (т.е. с такими же  методами, что и двусвязный список (см. лекцию)). Разница только в том,  что класс Item будет содержать ссылку только на next элемент. Ссылку на  предыдущий элемент Item не будет хранить! Поэтому список и называется  ОДНОСВЯЗНЫМ (Одна связь - только в сторону next). Создать класс  LinkedListTest и протестировать методы LinkedList <br><strong>Решение: </strong> <a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/Item.java" rel="noopener noreferrer" target="_blank"><strong>Item.java</strong></a><strong>,  </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/LinkedList.java" rel="noopener noreferrer" target="_blank"><strong>LinkedList.java</strong></a><strong>,  </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/LinkedListTest.java" rel="noopener noreferrer" target="_blank"><strong>LinkedListTest.java</strong></a><strong> </strong></p><p><br></p></li><li><p><strong>Задание:</strong> Создать класс Tree (Обычное дерево). В классе  будет одно поле Leaf root - корень дерева. В классе Leaf, который  представляет лист дерева, должны быть поля: int value (данное поле  хранит полезную информацию в листе дерева) и массив дочерних листов:  Leaf[] leaves. В классе Tree должны быть: </p><ul><li><p>конструктор Tree(int value) для создания дерева с одним корневым элементом со значением листа=value;</p></li><li><p>метод void add(int parentValue, int value) - данный метод находит  лист в дереве со значением parentValue и добавляет в него дочерний лист  со значением value. Если листа со значением parentValue нет в дереве, то  тогда отобразить соответствующее сообщение на консоль;</p></li><li><p>метод Tree getSubTree(int value) - возвращает поддерево с указанным  value в качестве корневого элемент или null, если такого value нет в  исходном дереве;</p></li><li><p>метод void print() - печатает текущее дерево в виде </p><pre class="prettyprint linenums">0
|-1
| |-11
| |-12
| |-13
|-2
| |-21
| |-22
| |-23
|-3
| |-31
| |-32
| |-33
</pre><p> , где 0 - корневой элемент, у которого дочерние элементы: 1,2,3. У элемента 1 дочерние элементы: 11,12,13 и т.д.<br> Числа 1,2,3 и др. являются значением value каждого листа данного дерева </p></li></ul><p><strong>Решение: </strong> <a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/Leaf.java" rel="noopener noreferrer" target="_blank"><strong>Leaf.java</strong></a><strong>,  </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/Tree.java" rel="noopener noreferrer" target="_blank"><strong>Tree.java</strong></a><strong>,  </strong><a href="https://github.com/devstudy-net/home-tasks/blob/master/src/main/java/net/devstudy/jse/lection01_classes_objects/TreeTest.java" rel="noopener noreferrer" target="_blank"><strong>TreeTest.java</strong></a><strong> </strong></p></li></ol>